## API Report File for "grammarkdown"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Cancelable } from '@esfx/cancelable';
import { CancellationToken } from 'prex';
import { CancelToken } from '@esfx/async-canceltoken';

// @public
export class Argument extends Node_2<SyntaxKind.Argument> {
    constructor(operatorToken: Token<ArgumentOperatorKind> | undefined, name: Identifier | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly name: Identifier | undefined;
    // (undocumented)
    readonly operatorToken: Token<ArgumentOperatorKind> | undefined;
    // (undocumented)
    update(name: Identifier | undefined): Argument;
}

// @public
export class ArgumentList extends Node_2<SyntaxKind.ArgumentList> {
    constructor(openParenToken: Token<SyntaxKind.OpenParenToken | SyntaxKind.OpenBracketToken>, elements: ReadonlyArray<Argument> | undefined, closeParenToken: Token<SyntaxKind.CloseParenToken | SyntaxKind.CloseBracketToken> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    readonly closeParenToken: Token<SyntaxKind.CloseParenToken | SyntaxKind.CloseBracketToken> | undefined;
    // (undocumented)
    readonly elements: ReadonlyArray<Argument> | undefined;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly openParenToken: Token<SyntaxKind.OpenParenToken | SyntaxKind.OpenBracketToken>;
    // (undocumented)
    update(elements: ReadonlyArray<Argument> | undefined): ArgumentList;
}

// @public (undocumented)
export type ArgumentOperatorKind = SyntaxKind.QuestionToken | SyntaxKind.PlusToken | SyntaxKind.TildeToken;

// @public (undocumented)
export type Assertion = AssertionTypes[AssertionKind];

// @public
export abstract class AssertionBase<TKind extends AssertionKind, TBracket extends SyntaxKind.OpenBracketToken | SyntaxKind.OpenBracketGreaterThanToken> extends LexicalSymbolBase<TKind> {
    constructor(kind: TKind, openBracketToken: Token<TBracket>, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    // (undocumented)
    readonly closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    abstract get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly openBracketToken: Token<TBracket>;
}

// @public (undocumented)
export type AssertionKind = keyof AssertionTypes;

// @public (undocumented)
export interface AssertionTypes {
}

// @public (undocumented)
export interface AssertionTypes {
    // (undocumented)
    [SyntaxKind.InvalidAssertion]: InvalidAssertion;
}

// @public (undocumented)
export interface AssertionTypes {
    // (undocumented)
    [SyntaxKind.EmptyAssertion]: EmptyAssertion;
}

// @public (undocumented)
export interface AssertionTypes {
    // (undocumented)
    [SyntaxKind.LookaheadAssertion]: LookaheadAssertion;
}

// @public (undocumented)
export interface AssertionTypes {
    // (undocumented)
    [SyntaxKind.LexicalGoalAssertion]: LexicalGoalAssertion;
}

// @public (undocumented)
export interface AssertionTypes {
    // (undocumented)
    [SyntaxKind.NoSymbolHereAssertion]: NoSymbolHereAssertion;
}

// @public (undocumented)
export interface AssertionTypes {
    // (undocumented)
    [SyntaxKind.ProseAssertion]: ProseAssertion;
}

// @public (undocumented)
export class AsyncHost extends HostBase {
    constructor({ readFile, writeFile, ...baseOptions }?: AsyncHostOptions);
    // (undocumented)
    static forFile(content: string, file?: string, hostFallback?: AsyncHost): AsyncSingleFileHost;
    // (undocumented)
    getSourceFile(file: string, cancelable?: Cancelable): Promise<SourceFile | undefined>;
    // @deprecated (undocumented)
    getSourceFile(file: string, cancelable?: CancellationToken | Cancelable): Promise<SourceFile | undefined>;
    // (undocumented)
    readFile(file: string, cancelable?: Cancelable): Promise<string | undefined>;
    // @deprecated (undocumented)
    readFile(file: string, cancelable?: CancellationToken | Cancelable): Promise<string | undefined>;
    // (undocumented)
    writeFile(file: string, text: string, cancelable?: Cancelable): Promise<void>;
    // @deprecated (undocumented)
    writeFile(file: string, text: string, cancelable?: CancellationToken | Cancelable): Promise<void>;
    }

// @public (undocumented)
export interface AsyncHostOptions extends HostBaseOptions {
    // (undocumented)
    readFile?: ReadFileCallback | LegacyReadFileCallback | false;
    // (undocumented)
    writeFile?: WriteFileCallback | LegacyWriteFileCallback | false;
}

// @public (undocumented)
export class AsyncSingleFileHost extends AsyncHost {
    constructor(file: string, content: string, hostFallback?: AsyncHost);
    // (undocumented)
    readonly content: string;
    // (undocumented)
    readonly file: string;
    // (undocumented)
    normalizeFile(file: string): string;
    // (undocumented)
    readFile(file: string, cancelable?: Cancelable): Promise<string | undefined>;
    // @deprecated (undocumented)
    readFile(file: string, cancelable?: CancellationToken | Cancelable): Promise<string | undefined>;
    // (undocumented)
    resolveFile(file: string, referer?: string): string;
    // (undocumented)
    writeFile(file: string, text: string, cancelable?: Cancelable): Promise<void>;
    // @deprecated (undocumented)
    writeFile(file: string, text: string, cancelable?: CancellationToken | Cancelable): Promise<void>;
}

// @public (undocumented)
export class Binder {
    // (undocumented)
    bindSourceFile(file: SourceFile, bindings: BindingTable, cancelable?: Cancelable): void;
    // @deprecated (undocumented)
    bindSourceFile(file: SourceFile, bindings: BindingTable, cancelable?: CancellationToken | Cancelable): void;
    }

// @public (undocumented)
export class BindingTable {
    // (undocumented)
    getAncestor(node: Node_2 | undefined, kind: SyntaxKind): Node_2 | undefined;
    // (undocumented)
    getDeclarations(symbol: Symbol_2 | undefined): (SourceFile | Production | Parameter)[];
    // (undocumented)
    getParent(node: Node_2 | undefined): Node_2 | undefined;
    // (undocumented)
    getReferences(symbol: Symbol_2 | undefined): Node_2[];
    // (undocumented)
    getSourceFile(node: Node_2 | undefined): SourceFile | undefined;
    // (undocumented)
    getSymbol(node: Node_2 | undefined): Symbol_2 | undefined;
    // (undocumented)
    readonly globals: SymbolTable;
    // (undocumented)
    hasParent(node: Node_2 | undefined): boolean;
    // (undocumented)
    hasSymbol(node: Node_2 | undefined): boolean;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    resolveSymbol(location: Node_2 | undefined, name: string | undefined, meaning: SymbolKind): Symbol_2 | undefined;
    }

// @public (undocumented)
export type BooleanKind = SyntaxKind.TrueKeyword | SyntaxKind.FalseKeyword;

// @public
export class ButNotSymbol extends LexicalSymbolBase<SyntaxKind.ButNotSymbol> {
    constructor(left: LexicalSymbol, butKeyword: Token<SyntaxKind.ButKeyword> | undefined, notKeyword: Token<SyntaxKind.NotKeyword> | undefined, right: LexicalSymbol | undefined);
    // (undocumented)
    readonly butKeyword: Token<SyntaxKind.ButKeyword> | undefined;
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly left: LexicalSymbol;
    // (undocumented)
    readonly notKeyword: Token<SyntaxKind.NotKeyword> | undefined;
    // (undocumented)
    readonly right: LexicalSymbol | undefined;
    // (undocumented)
    update(left: LexicalSymbol, right: LexicalSymbol | undefined): ButNotSymbol;
}

// @public (undocumented)
export const enum CharacterCodes {
    // (undocumented)
    Ampersand = 38,
    // (undocumented)
    Asterisk = 42,
    // (undocumented)
    At = 64,
    // (undocumented)
    Backslash = 92,
    // (undocumented)
    Backspace = 8,
    // (undocumented)
    Backtick = 96,
    // (undocumented)
    Bar = 124,
    // (undocumented)
    ByteOrderMark = 65279,
    // (undocumented)
    CarriageReturn = 13,
    // (undocumented)
    CloseBrace = 125,
    // (undocumented)
    CloseBracket = 93,
    // (undocumented)
    CloseParen = 41,
    // (undocumented)
    Colon = 58,
    // (undocumented)
    Comma = 44,
    // (undocumented)
    Dot = 46,
    // (undocumented)
    DoubleQuote = 34,
    // (undocumented)
    ElementOf = 8712,
    // (undocumented)
    EmQuad = 8193,
    // (undocumented)
    EmSpace = 8195,
    // (undocumented)
    EnQuad = 8192,
    // (undocumented)
    EnSpace = 8194,
    // (undocumented)
    Equals = 61,
    // (undocumented)
    Exclamation = 33,
    // (undocumented)
    FigureSpace = 8199,
    // (undocumented)
    FormFeed = 12,
    // (undocumented)
    FourPerEmSpace = 8197,
    // (undocumented)
    GreaterThan = 62,
    // (undocumented)
    HairSpace = 8202,
    // (undocumented)
    Hash = 35,
    // (undocumented)
    IdeographicSpace = 12288,
    // (undocumented)
    LessThan = 60,
    // (undocumented)
    LineFeed = 10,
    // (undocumented)
    LineSeparator = 8232,
    // (undocumented)
    LowerA = 97,
    // (undocumented)
    LowerB = 98,
    // (undocumented)
    LowerC = 99,
    // (undocumented)
    LowerD = 100,
    // (undocumented)
    LowerE = 101,
    // (undocumented)
    LowerF = 102,
    // (undocumented)
    LowerG = 103,
    // (undocumented)
    LowerH = 104,
    // (undocumented)
    LowerI = 105,
    // (undocumented)
    LowerJ = 106,
    // (undocumented)
    LowerK = 107,
    // (undocumented)
    LowerL = 108,
    // (undocumented)
    LowerM = 109,
    // (undocumented)
    LowerN = 110,
    // (undocumented)
    LowerO = 111,
    // (undocumented)
    LowerP = 112,
    // (undocumented)
    LowerQ = 113,
    // (undocumented)
    LowerR = 114,
    // (undocumented)
    LowerS = 115,
    // (undocumented)
    LowerT = 116,
    // (undocumented)
    LowerU = 117,
    // (undocumented)
    LowerV = 118,
    // (undocumented)
    LowerW = 119,
    // (undocumented)
    LowerX = 120,
    // (undocumented)
    LowerY = 121,
    // (undocumented)
    LowerZ = 122,
    // (undocumented)
    MathematicalSpace = 8287,
    // (undocumented)
    MaxAsciiCharacter = 127,
    // (undocumented)
    Minus = 45,
    // (undocumented)
    NarrowNoBreakSpace = 8239,
    // (undocumented)
    NextLine = 133,
    // (undocumented)
    NonBreakingSpace = 160,
    // (undocumented)
    NotAnElementOf = 8713,
    // (undocumented)
    NotEqualTo = 8800,
    // (undocumented)
    NullCharacter = 0,
    // (undocumented)
    Number0 = 48,
    // (undocumented)
    Number1 = 49,
    // (undocumented)
    Number2 = 50,
    // (undocumented)
    Number3 = 51,
    // (undocumented)
    Number4 = 52,
    // (undocumented)
    Number5 = 53,
    // (undocumented)
    Number6 = 54,
    // (undocumented)
    Number7 = 55,
    // (undocumented)
    Number8 = 56,
    // (undocumented)
    Number9 = 57,
    // (undocumented)
    NumberSign = 35,
    // (undocumented)
    Ogham = 5760,
    // (undocumented)
    OpenBrace = 123,
    // (undocumented)
    OpenBracket = 91,
    // (undocumented)
    OpenParen = 40,
    // (undocumented)
    ParagraphSeparator = 8233,
    // (undocumented)
    Plus = 43,
    // (undocumented)
    PunctuationSpace = 8200,
    // (undocumented)
    Question = 63,
    // (undocumented)
    Semicolon = 59,
    // (undocumented)
    SingleQuote = 39,
    // (undocumented)
    SixPerEmSpace = 8198,
    // (undocumented)
    Slash = 47,
    // (undocumented)
    Space = 32,
    // (undocumented)
    Tab = 9,
    // (undocumented)
    ThinSpace = 8201,
    // (undocumented)
    ThreePerEmSpace = 8196,
    // (undocumented)
    Tilde = 126,
    // (undocumented)
    Underscore = 95,
    // (undocumented)
    UpperA = 65,
    // (undocumented)
    UpperB = 66,
    // (undocumented)
    UpperC = 67,
    // (undocumented)
    UpperD = 68,
    // (undocumented)
    UpperE = 69,
    // (undocumented)
    UpperF = 70,
    // (undocumented)
    UpperG = 71,
    // (undocumented)
    UpperH = 72,
    // (undocumented)
    UpperI = 73,
    // (undocumented)
    UpperJ = 74,
    // (undocumented)
    UpperK = 75,
    // (undocumented)
    UpperL = 76,
    // (undocumented)
    UpperM = 77,
    // (undocumented)
    UpperN = 78,
    // (undocumented)
    UpperO = 79,
    // (undocumented)
    UpperP = 80,
    // (undocumented)
    UpperQ = 81,
    // (undocumented)
    UpperR = 82,
    // (undocumented)
    UpperS = 83,
    // (undocumented)
    UpperT = 84,
    // (undocumented)
    UpperU = 85,
    // (undocumented)
    UpperV = 86,
    // (undocumented)
    UpperW = 87,
    // (undocumented)
    UpperX = 88,
    // (undocumented)
    UpperY = 89,
    // (undocumented)
    UpperZ = 90,
    // (undocumented)
    VerticalTab = 11,
    // (undocumented)
    ZeroWidthSpace = 8203
}

// @public (undocumented)
export class Checker {
    constructor(options?: CompilerOptions);
    // (undocumented)
    checkSourceFile(sourceFile: SourceFile, bindings: BindingTable, diagnostics: DiagnosticMessages, cancelable?: Cancelable): void;
    // @deprecated (undocumented)
    checkSourceFile(sourceFile: SourceFile, bindings: BindingTable, diagnostics: DiagnosticMessages, cancelable?: CancellationToken | Cancelable): void;
    }

// @public (undocumented)
export type CommentTrivia = CommentTriviaTypes[CommentTriviaKind];

// @public
export abstract class CommentTriviaBase<TKind extends CommentTriviaKind> extends TriviaBase<TKind> {
}

// @public (undocumented)
export type CommentTriviaKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia;

// @public (undocumented)
export interface CommentTriviaTypes {
}

// @public (undocumented)
export interface CommentTriviaTypes {
    // (undocumented)
    [SyntaxKind.SingleLineCommentTrivia]: SingleLineCommentTrivia;
}

// @public (undocumented)
export interface CommentTriviaTypes {
    // (undocumented)
    [SyntaxKind.MultiLineCommentTrivia]: MultiLineCommentTrivia;
}

// @public (undocumented)
export interface CompilerOptions {
    // (undocumented)
    diagnostics?: boolean;
    // (undocumented)
    emitLinks?: boolean;
    // (undocumented)
    format?: EmitFormat;
    // (undocumented)
    newLine?: NewLineKind;
    // (undocumented)
    noChecks?: boolean;
    // (undocumented)
    noEmit?: boolean;
    // (undocumented)
    noEmitOnError?: boolean;
    // (undocumented)
    noStrictParametricProductions?: boolean;
    // (undocumented)
    noUnusedParameters?: boolean;
    // (undocumented)
    out?: string;
}

// @public
export class Constraints extends Node_2<SyntaxKind.Constraints> {
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketToken>, elements: ReadonlyArray<Argument> | undefined, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    readonly closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined;
    // (undocumented)
    readonly elements: ReadonlyArray<Argument> | undefined;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly openBracketToken: Token<SyntaxKind.OpenBracketToken>;
    // (undocumented)
    update(elements: ReadonlyArray<Argument> | undefined): Constraints;
}

// @public (undocumented)
export type Declaration = DeclarationTypes[DeclarationKind];

// @public (undocumented)
export type DeclarationKind = keyof DeclarationTypes;

// @public (undocumented)
export interface DeclarationTypes {
    // (undocumented)
    [SyntaxKind.Parameter]: Parameter;
}

// @public (undocumented)
export interface DeclarationTypes {
    // (undocumented)
    [SyntaxKind.Production]: Production;
}

// @public (undocumented)
export interface DeclarationTypes {
}

// @public (undocumented)
export interface DeclarationTypes {
    // (undocumented)
    [SyntaxKind.SourceFile]: SourceFile;
}

// @public
export class Define extends MetaElementBase<SyntaxKind.Define> {
    constructor(atToken: Token<SyntaxKind.AtToken>, defineKeyword: Token<SyntaxKind.DefineKeyword>, key: Identifier, valueToken: Token<BooleanKind> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    readonly defineKeyword: Token<SyntaxKind.DefineKeyword>;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    readonly key: Identifier;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly valueToken: Token<BooleanKind> | undefined;
}

// @public (undocumented)
export interface Diagnostic {
    // (undocumented)
    code: number;
    // (undocumented)
    message: string;
    // (undocumented)
    warning?: boolean;
}

// @public (undocumented)
export interface DiagnosticInfo {
    // (undocumented)
    code: number;
    // (undocumented)
    diagnosticIndex: number;
    // (undocumented)
    formattedMessage?: string;
    // (undocumented)
    message: string;
    // (undocumented)
    messageArguments: any[] | undefined;
    // (undocumented)
    node: Node_2 | undefined;
    // (undocumented)
    pos: number;
    // (undocumented)
    range: Range_2 | undefined;
    // (undocumented)
    sourceFile: SourceFile | undefined;
    // (undocumented)
    warning: boolean;
}

// @public (undocumented)
export class DiagnosticMessages {
    // (undocumented)
    [Symbol.iterator](): Generator<DiagnosticInfo | undefined, void, unknown>;
    // (undocumented)
    copyFrom(other: DiagnosticMessages): void;
    // (undocumented)
    count(): number;
    // (undocumented)
    forEach(callback: (message: string, diagnosticIndex: number) => void): void;
    // (undocumented)
    getDiagnostic(diagnosticIndex: number): Diagnostic | undefined;
    // (undocumented)
    getDiagnosticArguments(diagnosticIndex: number): any[] | undefined;
    // (undocumented)
    getDiagnosticInfo(diagnosticIndex: number, options?: {
        formatMessage?: boolean;
        detailedMessage?: boolean;
    }): DiagnosticInfo | undefined;
    // (undocumented)
    getDiagnosticInfos(options?: {
        formatMessage?: boolean;
        detailedMessage?: boolean;
    }): DiagnosticInfo[];
    // (undocumented)
    getDiagnosticInfosForSourceFile(sourceFile: SourceFile, options?: {
        formatMessage?: boolean;
        detailedMessage?: boolean;
    }): DiagnosticInfo[];
    // (undocumented)
    getDiagnosticNode(diagnosticIndex: number): Node_2 | undefined;
    // (undocumented)
    getDiagnosticRange(diagnosticIndex: number): Range_2 | undefined;
    // (undocumented)
    getDiagnosticSourceFile(diagnosticIndex: number): SourceFile | undefined;
    // (undocumented)
    getMessage(diagnosticIndex: number, options?: {
        detailed?: boolean;
    }): string;
    // (undocumented)
    report(pos: number, message: Diagnostic, ...args: any[]): void;
    // (undocumented)
    reportNode(sourceFile: SourceFile | undefined, node: Node_2, message: Diagnostic, ...args: any[]): void;
    // (undocumented)
    setSourceFile(sourceFile: SourceFile): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    values(): Generator<DiagnosticInfo | undefined, void, unknown>;
}

// @public (undocumented)
export const Diagnostics: {
    Constant_expected: {
        code: number;
        message: string;
    };
    _0_expected: {
        code: number;
        message: string;
    };
    _0_or_1_: {
        code: number;
        message: string;
    };
    Unexpected_token_0_: {
        code: number;
        message: string;
    };
    Invalid_character: {
        code: number;
        message: string;
    };
    Unterminated_string_literal: {
        code: number;
        message: string;
    };
    Invalid_escape_sequence: {
        code: number;
        message: string;
    };
    Digit_expected: {
        code: number;
        message: string;
    };
    Production_expected: {
        code: number;
        message: string;
    };
    Unterminated_identifier_literal: {
        code: number;
        message: string;
    };
    Obsolete_0_: {
        code: number;
        message: string;
        warning: true;
    };
    Cannot_find_name_0_: {
        code: number;
        message: string;
    };
    Duplicate_identifier_0_: {
        code: number;
        message: string;
    };
    Duplicate_terminal_0_: {
        code: number;
        message: string;
    };
    Argument_0_cannot_be_specified_multiple_times: {
        code: number;
        message: string;
    };
    Production_0_does_not_have_a_parameter_named_1_: {
        code: number;
        message: string;
    };
    Production_0_is_missing_parameter_1_All_definitions_of_production_0_must_specify_the_same_formal_parameters: {
        code: number;
        message: string;
    };
    There_is_no_argument_given_for_parameter_0_: {
        code: number;
        message: string;
    };
    Parameter_0_is_unused: {
        code: number;
        message: string;
    };
};

// @public (undocumented)
export class EcmarkupEmitter extends Emitter {
    // (undocumented)
    protected afterEmitNode(node: Node_2): void;
    // (undocumented)
    protected emitArgument(node: Argument): void;
    // (undocumented)
    protected emitArgumentList(node: ArgumentList): void;
    // (undocumented)
    protected emitButNotSymbol(node: ButNotSymbol): void;
    // (undocumented)
    protected emitConstraints(node: Constraints): void;
    // (undocumented)
    protected emitEmptyAssertion(node: EmptyAssertion): void;
    // (undocumented)
    protected emitLexicalGoalAssertion(node: LexicalGoalAssertion): void;
    // (undocumented)
    protected emitLookaheadAssertion(node: LookaheadAssertion): void;
    // (undocumented)
    protected emitNonterminal(node: Nonterminal): void;
    // (undocumented)
    protected emitNoSymbolHereAssertion(node: NoSymbolHereAssertion): void;
    // (undocumented)
    protected emitOneOfList(node: OneOfList): void;
    // (undocumented)
    protected emitOneOfSymbol(node: OneOfSymbol): void;
    // (undocumented)
    protected emitParameter(node: Parameter): void;
    // (undocumented)
    protected emitParameterList(node: ParameterList): void;
    // (undocumented)
    protected emitPlaceholder(node: LexicalSymbol): void;
    // (undocumented)
    protected emitProduction(node: Production): void;
    // (undocumented)
    protected emitProse(node: Prose): void;
    // (undocumented)
    protected emitProseAssertion(node: ProseAssertion): void;
    // (undocumented)
    protected emitRightHandSide(node: RightHandSide): void;
    // (undocumented)
    protected emitRightHandSideList(node: RightHandSideList): void;
    // (undocumented)
    protected emitSymbolSet(node: SymbolSet): void;
    // (undocumented)
    protected emitSymbolSpan(node: SymbolSpan): void;
    // (undocumented)
    protected emitTerminal(node: Terminal): void;
    // (undocumented)
    protected emitTextContent(node: TextContent): void;
    // (undocumented)
    protected emitUnicodeCharacterLiteral(node: UnicodeCharacterLiteral): void;
    // (undocumented)
    protected emitUnicodeCharacterRange(node: UnicodeCharacterRange): void;
    // (undocumented)
    protected extension: string;
}

// @public (undocumented)
export enum EmitFormat {
    // (undocumented)
    ecmarkup = 2,
    // (undocumented)
    html = 1,
    // (undocumented)
    markdown = 0
}

// @public (undocumented)
export class Emitter {
    constructor(options: CompilerOptions);
    // (undocumented)
    protected afterEmitNode(node: Node_2): void;
    // (undocumented)
    protected beforeEmitNode(node: Node_2): void;
    // (undocumented)
    protected createWriter(options: CompilerOptions): StringWriter;
    // (undocumented)
    emit(node: SourceFile, resolver: Resolver, diagnostics: DiagnosticMessages, writeFile: (file: string, text: string, cancelToken?: CancelToken) => void | PromiseLike<void>, cancelable?: Cancelable): Promise<void>;
    // @deprecated (undocumented)
    emit(node: SourceFile, resolver: Resolver, diagnostics: DiagnosticMessages, writeFile: (file: string, text: string, cancelToken?: CancellationToken & CancelToken) => void | PromiseLike<void>, cancelable?: CancellationToken | Cancelable): Promise<void>;
    // (undocumented)
    protected emitArgument(node: Argument): void;
    // (undocumented)
    protected emitArgumentList(node: ArgumentList): void;
    // (undocumented)
    protected emitButNotSymbol(node: ButNotSymbol): void;
    // (undocumented)
    protected emitConstraints(node: Constraints): void;
    // (undocumented)
    protected emitEmptyAssertion(node: EmptyAssertion): void;
    // Warning: (ae-forgotten-export) The symbol "TextRange" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected emitHtmlTrivia(range: TextRange): void;
    // (undocumented)
    protected emitIdentifier(node: Identifier): void;
    // (undocumented)
    protected emitImport(node: Import): void;
    // (undocumented)
    protected emitKeyword(node: Node_2): void;
    // (undocumented)
    protected emitLeadingHtmlTriviaOfNode(node: Node_2): void;
    // (undocumented)
    protected emitLexicalGoalAssertion(node: LexicalGoalAssertion): void;
    // (undocumented)
    protected emitLookaheadAssertion(node: LookaheadAssertion): void;
    // (undocumented)
    protected emitNode(node: Node_2 | undefined): void;
    // (undocumented)
    protected emitNonterminal(node: Nonterminal): void;
    // (undocumented)
    protected emitNoSymbolHereAssertion(node: NoSymbolHereAssertion): void;
    // (undocumented)
    protected emitOneOfList(node: OneOfList): void;
    // (undocumented)
    protected emitOneOfSymbol(node: OneOfSymbol): void;
    // (undocumented)
    protected emitParameter(node: Parameter): void;
    // (undocumented)
    protected emitParameterList(node: ParameterList): void;
    // (undocumented)
    protected emitPlaceholder(node: PlaceholderSymbol): void;
    // (undocumented)
    protected emitProduction(node: Production): void;
    // (undocumented)
    protected emitProse(node: Prose): void;
    // (undocumented)
    protected emitProseAssertion(node: ProseAssertion): void;
    // (undocumented)
    protected emitProseFragmentLiteral(node: ProseFragmentLiteral): void;
    // (undocumented)
    protected emitRightHandSide(node: RightHandSide): void;
    // (undocumented)
    protected emitRightHandSideList(node: RightHandSideList): void;
    // (undocumented)
    protected emitSourceFile(node: SourceFile): void;
    // (undocumented)
    emitString(node: SourceFile, resolver: Resolver, diagnostics: DiagnosticMessages, cancelable?: Cancelable): string;
    // @deprecated (undocumented)
    emitString(node: SourceFile, resolver: Resolver, diagnostics: DiagnosticMessages, cancelable?: CancellationToken | Cancelable): string;
    // (undocumented)
    protected emitSymbolSet(node: SymbolSet): void;
    // (undocumented)
    protected emitSymbolSpan(node: SymbolSpan): void;
    // (undocumented)
    emitSync(node: SourceFile, resolver: Resolver, diagnostics: DiagnosticMessages, writeFile: (file: string, text: string, cancelToken?: CancelToken) => void, cancelable?: Cancelable): void;
    // @deprecated (undocumented)
    emitSync(node: SourceFile, resolver: Resolver, diagnostics: DiagnosticMessages, writeFile: (file: string, text: string, cancelToken?: CancellationToken & CancelToken) => void, cancelable?: CancellationToken | Cancelable): void;
    // (undocumented)
    protected emitTerminal(node: Terminal): void;
    // (undocumented)
    protected emitTextContent(node: TextContent): void;
    // (undocumented)
    protected emitToken(node: Node_2 | undefined): void;
    // (undocumented)
    protected emitTrailingHtmlTriviaOfNode(node: Node_2): void;
    // (undocumented)
    protected emitUnicodeCharacterLiteral(node: UnicodeCharacterLiteral): void;
    // (undocumented)
    protected emitUnicodeCharacterRange(node: UnicodeCharacterRange): void;
    // (undocumented)
    protected encode(text: string): string;
    // (undocumented)
    protected extension: string;
    // (undocumented)
    protected getOutputFilename(node: SourceFile): string;
    // (undocumented)
    protected options: CompilerOptions;
    // (undocumented)
    protected resolver: Resolver;
    // (undocumented)
    protected writer: StringWriter;
}

// @public
export class EmptyAssertion extends AssertionBase<SyntaxKind.EmptyAssertion, SyntaxKind.OpenBracketToken> {
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketToken>, emptyKeyword: Token<SyntaxKind.EmptyKeyword>, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    readonly emptyKeyword: Token<SyntaxKind.EmptyKeyword>;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
}

// @public (undocumented)
export function forEachChild<T>(node: Node_2 | undefined, cbNode: (node: Node_2) => T | undefined): T | undefined;

// @public (undocumented)
export function formatList(tokens: (SyntaxKind | string)[]): string;

// @public (undocumented)
export function formatString(format: string, args?: any[]): string;

// @public (undocumented)
export function formatString(format: string, ...args: any[]): string;

// @public (undocumented)
export function getDefaultOptions(): CompilerOptions;

// @public (undocumented)
export class Grammar {
    constructor(rootNames: Iterable<string>, options?: CompilerOptions, host?: Host | SyncHost | AsyncHost);
    // (undocumented)
    bind(cancelable?: Cancelable): Promise<void>;
    // @deprecated (undocumented)
    bind(cancelable?: CancellationToken | Cancelable): Promise<void>;
    // (undocumented)
    protected get binder(): Binder;
    // (undocumented)
    bindSync(cancelable?: Cancelable): void;
    // @deprecated (undocumented)
    bindSync(cancelable?: CancellationToken | Cancelable): void;
    // (undocumented)
    check(sourceFile?: SourceFile, cancelable?: Cancelable): Promise<void>;
    // @deprecated (undocumented)
    check(sourceFile?: SourceFile, cancelable?: CancellationToken | Cancelable): Promise<void>;
    // (undocumented)
    protected get checker(): Checker;
    // (undocumented)
    checkSync(sourceFile?: SourceFile, cancelable?: Cancelable): void;
    // @deprecated (undocumented)
    checkSync(sourceFile?: SourceFile, cancelable?: CancellationToken | Cancelable): void;
    // (undocumented)
    static convert(content: string, options?: CompilerOptions, hostFallback?: Host | SyncHost | AsyncHost, cancelable?: Cancelable): string;
    // @deprecated (undocumented)
    static convert(content: string, options?: CompilerOptions, hostFallback?: Host | SyncHost | AsyncHost, cancelable?: CancellationToken | Cancelable): string;
    // (undocumented)
    protected createBinder(options: CompilerOptions): Binder;
    // (undocumented)
    protected createChecker(options: CompilerOptions): Checker;
    // (undocumented)
    protected createEmitter(options: CompilerOptions): Emitter;
    // (undocumented)
    protected createResolver(bindings: BindingTable): Resolver;
    // (undocumented)
    diagnostics: DiagnosticMessages;
    // (undocumented)
    emit(sourceFile?: SourceFile, writeFile?: (file: string, output: string, cancelToken?: CancelToken) => void | PromiseLike<void>, cancelable?: Cancelable): Promise<void>;
    // @deprecated (undocumented)
    emit(sourceFile?: SourceFile, writeFile?: (file: string, output: string) => void | PromiseLike<void>, cancelable?: CancellationToken | Cancelable): Promise<void>;
    // (undocumented)
    emitString(sourceFile: SourceFile, cancelable?: Cancelable): Promise<string>;
    // @deprecated (undocumented)
    emitString(sourceFile: SourceFile, cancelable?: CancellationToken | Cancelable): Promise<string>;
    // (undocumented)
    emitStringSync(sourceFile: SourceFile, cancelable?: Cancelable): string;
    // @deprecated (undocumented)
    emitStringSync(sourceFile: SourceFile, cancelable?: CancellationToken | Cancelable): string;
    // (undocumented)
    emitSync(sourceFile?: SourceFile, writeFile?: (file: string, output: string, cancelToken?: CancelToken) => void, cancelable?: Cancelable): void;
    // @deprecated (undocumented)
    emitSync(sourceFile?: SourceFile, writeFile?: (file: string, output: string) => void, cancelable?: CancellationToken | Cancelable): void;
    // (undocumented)
    protected get emitter(): Emitter;
    // (undocumented)
    getSourceFile(file: string): SourceFile | undefined;
    // (undocumented)
    readonly host: Host | SyncHost | AsyncHost;
    // (undocumented)
    get isBound(): boolean;
    // (undocumented)
    get isParsed(): boolean;
    // (undocumented)
    options: CompilerOptions;
    // (undocumented)
    parse(cancelable?: Cancelable): Promise<void>;
    // @deprecated (undocumented)
    parse(cancelable?: CancellationToken | Cancelable): Promise<void>;
    // (undocumented)
    parseSync(cancelable?: Cancelable): void;
    // @deprecated (undocumented)
    parseSync(cancelable?: CancellationToken | Cancelable): void;
    // (undocumented)
    protected readFile(file: string, cancelToken?: CancelToken): Promise<string | undefined> | string | undefined;
    // (undocumented)
    protected readFileSync(file: string): Promise<string | undefined> | string | undefined;
    // (undocumented)
    get resolver(): Resolver;
    // (undocumented)
    get rootFiles(): ReadonlyArray<SourceFile>;
    // (undocumented)
    get sourceFiles(): ReadonlyArray<SourceFile>;
    // (undocumented)
    protected writeFile(file: string, content: string, cancelToken?: CancelToken): void | Promise<void>;
    // (undocumented)
    protected writeFileSync(file: string, content: string): void;
    }

// @public @deprecated (undocumented)
export class Host extends HostBase {
    constructor({ readFile, readFileSync, writeFile, writeFileSync, ...baseOptions }?: HostOptions);
    // (undocumented)
    getSourceFile(file: string, cancelable?: Cancelable): Promise<SourceFile | undefined>;
    // @deprecated (undocumented)
    getSourceFile(file: string, cancelable?: CancellationToken | Cancelable): Promise<SourceFile | undefined>;
    // (undocumented)
    getSourceFileSync(file: string, cancelable?: Cancelable): SourceFile | undefined;
    // @deprecated (undocumented)
    getSourceFileSync(file: string, cancelable?: CancellationToken | Cancelable): SourceFile | undefined;
    // (undocumented)
    readFile(file: string, cancelable?: Cancelable): Promise<string | undefined>;
    // @deprecated (undocumented)
    readFile(file: string, cancelable?: CancellationToken | Cancelable): Promise<string | undefined>;
    // (undocumented)
    readFileSync(file: string, cancelable?: Cancelable): string | undefined;
    // @deprecated (undocumented)
    readFileSync(file: string, cancelable?: CancellationToken | Cancelable): string | undefined;
    // (undocumented)
    writeFile(file: string, text: string, cancelable?: Cancelable): Promise<void>;
    // @deprecated (undocumented)
    writeFile(file: string, text: string, cancelable?: CancellationToken | Cancelable): Promise<void>;
    // (undocumented)
    writeFileSync(file: string, text: string, cancelable?: Cancelable): void;
    // @deprecated (undocumented)
    writeFileSync(file: string, text: string, cancelable?: CancellationToken | Cancelable): void;
    }

// @public (undocumented)
export abstract class HostBase {
    constructor({ ignoreCase, knownGrammars, useBuiltinGrammars }?: HostBaseOptions);
    // (undocumented)
    protected createParser(): Parser;
    // (undocumented)
    readonly ignoreCase: boolean;
    // (undocumented)
    normalizeFile(file: string): string;
    // (undocumented)
    protected get parser(): Parser;
    // (undocumented)
    parseSourceFile(file: string, text: string, cancelable?: Cancelable): SourceFile;
    // @deprecated (undocumented)
    parseSourceFile(file: string, text: string, cancelable?: CancellationToken | Cancelable): SourceFile;
    // (undocumented)
    registerKnownGrammar(name: string, file: string): void;
    // (undocumented)
    protected resolveBuiltInGrammar(name: string): string | undefined;
    // (undocumented)
    resolveFile(file: string, referer?: string): string;
    // (undocumented)
    resolveKnownGrammar(name: string): string | undefined;
    }

// @public (undocumented)
export interface HostBaseOptions {
    // (undocumented)
    ignoreCase?: boolean;
    // (undocumented)
    knownGrammars?: Record<string, string>;
    // (undocumented)
    useBuiltinGrammars?: boolean;
}

// @public (undocumented)
export interface HostOptions extends HostBaseOptions {
    // (undocumented)
    readFile?: ReadFileCallback | LegacyReadFileCallback;
    // (undocumented)
    readFileSync?: ReadFileSyncCallback | LegacyReadFileSyncCallback;
    // (undocumented)
    writeFile?: WriteFileCallback | LegacyWriteFileCallback;
    // (undocumented)
    writeFileSync?: WriteFileSyncCallback | LegacyWriteFileSyncCallback;
}

// @public
export class HtmlCloseTagTrivia extends HtmlTriviaBase<SyntaxKind.HtmlCloseTagTrivia> {
    constructor(tagName: string);
}

// @public (undocumented)
export class HtmlEmitter extends Emitter {
    // (undocumented)
    protected afterEmitNode(node: Node_2): void;
    // (undocumented)
    protected emitArgument(node: Argument): void;
    // (undocumented)
    protected emitArgumentList(node: ArgumentList): void;
    // (undocumented)
    protected emitButNotSymbol(node: ButNotSymbol): void;
    // (undocumented)
    protected emitConstraints(node: Constraints): void;
    // (undocumented)
    protected emitEmptyAssertion(node: EmptyAssertion): void;
    // (undocumented)
    protected emitLexicalGoalAssertion(node: LexicalGoalAssertion): void;
    // (undocumented)
    protected emitLookaheadAssertion(node: LookaheadAssertion): void;
    // (undocumented)
    protected emitNonterminal(node: Nonterminal): void;
    // (undocumented)
    protected emitNoSymbolHereAssertion(node: NoSymbolHereAssertion): void;
    // (undocumented)
    protected emitOneOfList(node: OneOfList): void;
    // (undocumented)
    protected emitOneOfSymbol(node: OneOfSymbol): void;
    // (undocumented)
    protected emitParameter(node: Parameter): void;
    // (undocumented)
    protected emitParameterList(node: ParameterList): void;
    // (undocumented)
    protected emitPlaceholder(node: LexicalSymbol): void;
    // (undocumented)
    protected emitProduction(node: Production): void;
    // (undocumented)
    protected emitProse(node: Prose): void;
    // (undocumented)
    protected emitProseAssertion(node: ProseAssertion): void;
    // (undocumented)
    protected emitRightHandSide(node: RightHandSide): void;
    // (undocumented)
    protected emitRightHandSideList(node: RightHandSideList): void;
    // (undocumented)
    protected emitSourceFile(node: SourceFile): void;
    // (undocumented)
    protected emitSymbolSet(node: SymbolSet): void;
    // (undocumented)
    protected emitSymbolSpan(node: SymbolSpan): void;
    // (undocumented)
    protected emitTerminal(node: Terminal): void;
    // (undocumented)
    protected emitTextContent(node: TextContent): void;
    // (undocumented)
    protected emitUnicodeCharacterLiteral(node: UnicodeCharacterLiteral): void;
    // (undocumented)
    protected emitUnicodeCharacterRange(node: UnicodeCharacterRange): void;
    // (undocumented)
    protected extension: string;
}

// @public
export class HtmlOpenTagTrivia extends HtmlTriviaBase<SyntaxKind.HtmlOpenTagTrivia> {
    constructor(tagName: string);
}

// @public (undocumented)
export type HtmlTrivia = HtmlTriviaTypes[HtmlTriviaKind];

// @public
export abstract class HtmlTriviaBase<TKind extends HtmlTriviaKind> extends TriviaBase<TKind> {
    constructor(kind: TKind, tagName: string);
    // (undocumented)
    readonly tagName: string;
}

// @public (undocumented)
export type HtmlTriviaKind = SyntaxKind.HtmlOpenTagTrivia | SyntaxKind.HtmlCloseTagTrivia;

// @public (undocumented)
export interface HtmlTriviaTypes {
}

// @public (undocumented)
export interface HtmlTriviaTypes {
    // (undocumented)
    [SyntaxKind.HtmlOpenTagTrivia]: HtmlOpenTagTrivia;
}

// @public (undocumented)
export interface HtmlTriviaTypes {
    // (undocumented)
    [SyntaxKind.HtmlCloseTagTrivia]: HtmlCloseTagTrivia;
}

// @public
export class Identifier extends Node_2<SyntaxKind.Identifier> implements TextContent {
    constructor(text: string | undefined);
    // (undocumented)
    readonly text: string | undefined;
}

// @public
export class Import extends MetaElementBase<SyntaxKind.Import> {
    constructor(atToken: Token<SyntaxKind.AtToken>, importKeyword: Token<SyntaxKind.ImportKeyword>, path: StringLiteral | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    readonly importKeyword: Token<SyntaxKind.ImportKeyword>;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly path: StringLiteral | undefined;
}

// @public
export class InvalidAssertion extends AssertionBase<SyntaxKind.InvalidAssertion, SyntaxKind.OpenBracketToken> {
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketToken>, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
}

// @public
export class InvalidSymbol extends LexicalSymbolBase<SyntaxKind.InvalidSymbol> {
    constructor();
}

// @public (undocumented)
export function isCommentTriviaKind(kind: SyntaxKind): kind is CommentTriviaKind;

// @public (undocumented)
export function isHtmlTriviaKind(kind: SyntaxKind): kind is HtmlTriviaKind;

// @public (undocumented)
export function isKeywordKind(kind: SyntaxKind): kind is KeywordKind;

// @public (undocumented)
export function isProseFragmentLiteralKind(kind: SyntaxKind): kind is ProseFragmentLiteralKind;

// @public (undocumented)
export function isPunctuationKind(kind: SyntaxKind): kind is PunctuationKind;

// @public (undocumented)
export function isTextContentKind(kind: SyntaxKind): kind is TextContentKind;

// @public (undocumented)
export function isTokenKind(kind: SyntaxKind): kind is TokenKind;

// @public (undocumented)
export function isTriviaKind(kind: SyntaxKind): kind is TriviaKind;

// @public (undocumented)
export type KeywordKind = SyntaxKind.ButKeyword | SyntaxKind.DefineKeyword | SyntaxKind.EmptyKeyword | SyntaxKind.FalseKeyword | SyntaxKind.GoalKeyword | SyntaxKind.HereKeyword | SyntaxKind.ImportKeyword | SyntaxKind.LexicalKeyword | SyntaxKind.LookaheadKeyword | SyntaxKind.NoKeyword | SyntaxKind.NotKeyword | SyntaxKind.OfKeyword | SyntaxKind.OneKeyword | SyntaxKind.OrKeyword | SyntaxKind.ThroughKeyword | SyntaxKind.TrueKeyword;

// @public (undocumented)
export interface KnownOption {
    // (undocumented)
    aliasFor?: string[];
    // (undocumented)
    convert?: (key: string, value: string, raw: RawArguments) => any;
    // (undocumented)
    description?: string;
    // (undocumented)
    error?: string;
    // (undocumented)
    hidden?: boolean;
    // (undocumented)
    isUsage?: boolean;
    // (undocumented)
    longName: string;
    // (undocumented)
    many?: boolean;
    // (undocumented)
    param?: string;
    // (undocumented)
    shortName?: string;
    // (undocumented)
    type?: string | Map<string, any>;
    // (undocumented)
    validate?: (key: string, value: string, raw: RawArguments) => boolean;
}

// @public (undocumented)
export interface KnownOptions {
    // (undocumented)
    [name: string]: Partial<KnownOption>;
}

// @public @deprecated (undocumented)
export type LegacyReadFileCallback = (this: never, file: string, cancelToken?: CancellationToken) => PromiseLike<string> | string;

// @public @deprecated (undocumented)
export type LegacyReadFileSyncCallback = (this: never, file: string, cancelToken?: CancellationToken) => string;

// @public @deprecated (undocumented)
export type LegacyWriteFileCallback = (this: never, file: string, content: string, cancelToken?: CancellationToken) => PromiseLike<void> | void;

// @public @deprecated (undocumented)
export type LegacyWriteFileSyncCallback = (this: never, file: string, content: string, cancelToken?: CancellationToken) => void;

// @public
export class LexicalGoalAssertion extends AssertionBase<SyntaxKind.LexicalGoalAssertion, SyntaxKind.OpenBracketToken> {
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketToken>, lexicalKeyword: Token<SyntaxKind.LexicalKeyword>, goalKeyword: Token<SyntaxKind.GoalKeyword> | undefined, symbol: Identifier | undefined, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    readonly goalKeyword: Token<SyntaxKind.GoalKeyword> | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly lexicalKeyword: Token<SyntaxKind.LexicalKeyword>;
    // (undocumented)
    readonly symbol: Identifier | undefined;
    // (undocumented)
    update(symbol: Identifier | undefined): LexicalGoalAssertion;
}

// @public (undocumented)
export type LexicalSymbol = LexicalSymbolTypes[LexicalSymbolKind];

// @public
export abstract class LexicalSymbolBase<TKind extends LexicalSymbolKind> extends Node_2<TKind> {
}

// @public (undocumented)
export type LexicalSymbolKind = keyof LexicalSymbolTypes;

// @public (undocumented)
export interface LexicalSymbolTypes extends PrimarySymbolTypes, AssertionTypes {
}

// @public (undocumented)
export interface LexicalSymbolTypes {
    // (undocumented)
    [SyntaxKind.InvalidSymbol]: InvalidSymbol;
}

// @public (undocumented)
export interface LexicalSymbolTypes {
    // (undocumented)
    [SyntaxKind.PlaceholderSymbol]: PlaceholderSymbol;
}

// @public (undocumented)
export interface LexicalSymbolTypes {
    // (undocumented)
    [SyntaxKind.UnicodeCharacterRange]: UnicodeCharacterRange;
}

// @public (undocumented)
export interface LexicalSymbolTypes {
    // (undocumented)
    [SyntaxKind.ButNotSymbol]: ButNotSymbol;
}

// @public (undocumented)
export interface LexicalSymbolTypes {
    // (undocumented)
    [SyntaxKind.Prose]: Prose;
}

// @public (undocumented)
export interface LexicalSymbolTypes {
    // (undocumented)
    [SyntaxKind.OneOfSymbol]: OneOfSymbol;
}

// @public (undocumented)
export class LineMap {
    constructor(text: string);
    // (undocumented)
    formatOffset(pos: number): string;
    // (undocumented)
    get lineCount(): number;
    // (undocumented)
    offsetAt(position: Position_2): number;
    // (undocumented)
    positionAt(offset: number): Position_2;
    }

// @public
export class LinkReference extends Node_2<SyntaxKind.LinkReference> {
    constructor(text: string | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    forEachChild<T>(_cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    readonly text: string | undefined;
}

// @public
export class LookaheadAssertion extends AssertionBase<SyntaxKind.LookaheadAssertion, SyntaxKind.OpenBracketToken> {
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketToken>, lookaheadKeyword: Token<SyntaxKind.LookaheadKeyword>, operatorToken: Token<LookaheadOperatorKind> | undefined, lookahead: SymbolSpan | SymbolSet | undefined, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly lookahead: SymbolSpan | SymbolSet | undefined;
    // (undocumented)
    readonly lookaheadKeyword: Token<SyntaxKind.LookaheadKeyword>;
    // (undocumented)
    readonly operatorToken: Token<LookaheadOperatorKind> | undefined;
    // (undocumented)
    update(lookahead: SymbolSpan | SymbolSet | undefined): LookaheadAssertion;
}

// @public (undocumented)
export type LookaheadOperatorKind = SyntaxKind.EqualsToken | SyntaxKind.EqualsEqualsToken | SyntaxKind.ExclamationEqualsToken | SyntaxKind.NotEqualToToken | SyntaxKind.LessThanMinusToken | SyntaxKind.ElementOfToken | SyntaxKind.LessThanExclamationToken | SyntaxKind.NotAnElementOfToken;

// @public (undocumented)
export class MarkdownEmitter extends Emitter {
    // (undocumented)
    protected afterEmitNode(node: Node_2): void;
    // (undocumented)
    protected emitArgument(node: Argument): void;
    // (undocumented)
    protected emitArgumentList(node: ArgumentList): void;
    // (undocumented)
    protected emitButNotSymbol(node: ButNotSymbol): void;
    // (undocumented)
    protected emitConstraints(node: Constraints): void;
    // (undocumented)
    protected emitEmptyAssertion(node: EmptyAssertion): void;
    // (undocumented)
    protected emitKeyword(node: Node_2): void;
    // (undocumented)
    protected emitLexicalGoalAssertion(node: LexicalGoalAssertion): void;
    // (undocumented)
    protected emitLookaheadAssertion(node: LookaheadAssertion): void;
    // (undocumented)
    protected emitNonterminal(node: Nonterminal): void;
    // (undocumented)
    protected emitNoSymbolHereAssertion(node: NoSymbolHereAssertion): void;
    // (undocumented)
    protected emitOneOfList(node: OneOfList): void;
    // (undocumented)
    protected emitOneOfSymbol(node: OneOfSymbol): void;
    // (undocumented)
    protected emitParameter(node: Parameter): void;
    // (undocumented)
    protected emitParameterList(node: ParameterList): void;
    // (undocumented)
    protected emitProduction(node: Production): void;
    // (undocumented)
    protected emitProseAssertion(node: ProseAssertion): void;
    // (undocumented)
    protected emitRightHandSide(node: RightHandSide): void;
    // (undocumented)
    protected emitRightHandSideList(node: RightHandSideList): void;
    // (undocumented)
    protected emitSymbolSet(node: SymbolSet): void;
    // (undocumented)
    protected emitSymbolSpan(node: SymbolSpan): void;
    // (undocumented)
    protected emitTerminal(node: Terminal): void;
    // (undocumented)
    protected emitTextContent(node: TextContent): void;
    // (undocumented)
    protected emitUnicodeCharacterLiteral(node: UnicodeCharacterLiteral): void;
    // (undocumented)
    protected emitUnicodeCharacterRange(node: UnicodeCharacterRange): void;
    // (undocumented)
    protected extension: string;
}

// @public (undocumented)
export type MetaElement = MetaElementTypes[MetaElementKind];

// @public
export abstract class MetaElementBase<TKind extends MetaElementKind> extends SourceElementBase<TKind> {
    constructor(kind: TKind, atToken: Token<SyntaxKind.AtToken>);
    // (undocumented)
    readonly atToken: Token<SyntaxKind.AtToken>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
}

// @public (undocumented)
export type MetaElementKind = keyof MetaElementTypes;

// @public (undocumented)
export interface MetaElementTypes {
}

// @public (undocumented)
export interface MetaElementTypes {
    // (undocumented)
    [SyntaxKind.Import]: Import;
}

// @public (undocumented)
export interface MetaElementTypes {
    // (undocumented)
    [SyntaxKind.Define]: Define;
}

// @public
export class MultiLineCommentTrivia extends CommentTriviaBase<SyntaxKind.MultiLineCommentTrivia> {
    constructor();
}

// @public (undocumented)
export enum NewLineKind {
    // (undocumented)
    CarriageReturnLineFeed = 1,
    // (undocumented)
    LineFeed = 0
}

// @public
abstract class Node_2<TKind extends SyntaxKind = SyntaxKind> implements TextRange {
    constructor(kind: TKind);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    end: number;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(_cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    getEnd(): number;
    // (undocumented)
    getFullStart(): number;
    // (undocumented)
    getFullText(sourceFile: SourceFile): string;
    // (undocumented)
    getFullWidth(): number;
    // (undocumented)
    getStart(sourceFile?: SourceFile): number;
    // (undocumented)
    getText(sourceFile: SourceFile): string;
    // (undocumented)
    getWidth(sourceFile?: SourceFile): number;
    // (undocumented)
    readonly kind: TKind;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    leadingHtmlTrivia: HtmlTrivia[] | undefined;
    // (undocumented)
    pos: number;
    // (undocumented)
    trailingHtmlTrivia: HtmlTrivia[] | undefined;
}

export { Node_2 as Node }

// @public (undocumented)
export class NodeNavigator {
    constructor(sourceFile: SourceFile);
    constructor(other: NodeNavigator);
    // (undocumented)
    clone(): NodeNavigator;
    // (undocumented)
    getArray(): readonly Node_2<SyntaxKind>[] | undefined;
    // (undocumented)
    getDepth(): number;
    // (undocumented)
    getKind(): SyntaxKind;
    // (undocumented)
    getName(): string | undefined;
    // (undocumented)
    getNode(): Node_2<SyntaxKind>;
    // (undocumented)
    getOffset(): number;
    // (undocumented)
    getParent(): Node_2<SyntaxKind> | undefined;
    // (undocumented)
    getRoot(): SourceFile;
    // (undocumented)
    hasAncestor(predicate?: (node: Node_2) => boolean): boolean;
    // (undocumented)
    hasChildren(predicate?: (node: Node_2) => boolean): boolean;
    // (undocumented)
    isArray(): boolean;
    // (undocumented)
    isSamePosition(other: NodeNavigator): boolean;
    // (undocumented)
    moveTo(other: NodeNavigator): boolean;
    // (undocumented)
    moveToAncestor(predicate: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToAncestorOrSelf(predicate: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToDeclaration(): boolean;
    // (undocumented)
    moveToFirstChild(): boolean;
    // (undocumented)
    moveToFirstChild(name: string): boolean;
    // (undocumented)
    moveToFirstChild(predicate: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToFirstElement(predicate?: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToFirstSibling(): boolean;
    // (undocumented)
    moveToFirstSibling(name: string): boolean;
    // (undocumented)
    moveToFirstSibling(predicate: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToLastChild(): boolean;
    // (undocumented)
    moveToLastChild(name: string): boolean;
    // (undocumented)
    moveToLastChild(predicate: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToLastElement(predicate?: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToLastSibling(): boolean;
    // (undocumented)
    moveToLastSibling(name: string): boolean;
    // (undocumented)
    moveToLastSibling(predicate: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToName(): boolean;
    // (undocumented)
    moveToNextElement(predicate?: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToNextSibling(): boolean;
    // (undocumented)
    moveToNextSibling(name: string): boolean;
    // (undocumented)
    moveToNextSibling(predicate: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToParent(predicate?: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToPosition(position: Position_2): boolean;
    // (undocumented)
    moveToPreviousElement(predicate?: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToPreviousSibling(): boolean;
    // (undocumented)
    moveToPreviousSibling(name: string): boolean;
    // (undocumented)
    moveToPreviousSibling(predicate: (node: Node_2) => boolean): boolean;
    // (undocumented)
    moveToRoot(): boolean;
    // (undocumented)
    moveToSourceElement(): boolean;
    }

// @public (undocumented)
export abstract class NodeVisitor {
    // (undocumented)
    visit<T extends Node_2>(node: T): T;
    // (undocumented)
    visit<T extends Node_2>(node: T | undefined): T | undefined;
    // (undocumented)
    visitArgument(node: Argument): Argument;
    // (undocumented)
    visitArgumentList(node: ArgumentList): ArgumentList;
    // (undocumented)
    visitButNotSymbol(node: ButNotSymbol): ButNotSymbol;
    // (undocumented)
    visitConstraints(node: Constraints): Constraints;
    // (undocumented)
    visitDefine(node: Define): Define;
    // (undocumented)
    visitEach<T extends Node_2>(nodes: ReadonlyArray<T>): ReadonlyArray<T>;
    // (undocumented)
    visitEach<T extends Node_2>(nodes: ReadonlyArray<T> | undefined): ReadonlyArray<T> | undefined;
    // (undocumented)
    visitEmptyAssertion(node: EmptyAssertion): EmptyAssertion;
    // (undocumented)
    visitExtension<T extends Node_2>(node: T): T;
    // (undocumented)
    visitIdentifier(node: Identifier): Identifier;
    // (undocumented)
    visitImport(node: Import): Import;
    // (undocumented)
    visitInvalidAssertion(node: InvalidAssertion): InvalidAssertion;
    // (undocumented)
    visitInvalidSymbol(node: InvalidSymbol): InvalidSymbol;
    // (undocumented)
    visitLexicalGoalAssertion(node: LexicalGoalAssertion): LexicalGoalAssertion;
    // (undocumented)
    visitLinkReference(node: LinkReference): LinkReference;
    // (undocumented)
    visitLookaheadAssertion(node: LookaheadAssertion): LookaheadAssertion;
    // (undocumented)
    visitNonterminal(node: Nonterminal): Nonterminal;
    // (undocumented)
    visitNoSymbolHereAssertion(node: NoSymbolHereAssertion): NoSymbolHereAssertion;
    // (undocumented)
    visitOneOfList(node: OneOfList): OneOfList;
    // (undocumented)
    visitOneOfSymbol(node: OneOfSymbol): OneOfSymbol;
    // (undocumented)
    visitParameter(node: Parameter): Parameter;
    // (undocumented)
    visitParameterList(node: ParameterList): ParameterList;
    // (undocumented)
    visitPlaceholderSymbol(node: PlaceholderSymbol): PlaceholderSymbol;
    // (undocumented)
    visitProduction(node: Production): Production;
    // (undocumented)
    visitProse(node: Prose): Prose;
    // (undocumented)
    visitProseAssertion(node: ProseAssertion): ProseAssertion;
    // (undocumented)
    visitProseFragmentLiteral(node: ProseFragmentLiteral): ProseFragmentLiteral;
    // (undocumented)
    visitRightHandSide(node: RightHandSide): RightHandSide;
    // (undocumented)
    visitRightHandSideList(node: RightHandSideList): RightHandSideList;
    // (undocumented)
    visitSourceFile(node: SourceFile): SourceFile;
    // (undocumented)
    visitStringLiteral(node: StringLiteral): StringLiteral;
    // (undocumented)
    visitSymbolSet(node: SymbolSet): SymbolSet;
    // (undocumented)
    visitSymbolSpan(node: SymbolSpan): SymbolSpan;
    // (undocumented)
    visitTerminal(node: Terminal): Terminal;
    // (undocumented)
    visitToken<TKind extends TokenKind>(node: Token<TKind>): Token<TKind>;
    // (undocumented)
    visitUnicodeCharacterLiteral(node: UnicodeCharacterLiteral): UnicodeCharacterLiteral;
    // (undocumented)
    visitUnicodeCharacterRange(node: UnicodeCharacterRange): UnicodeCharacterRange;
}

// @public
export class Nonterminal extends OptionalSymbolBase<SyntaxKind.Nonterminal> {
    constructor(name: Identifier, argumentList: ArgumentList | undefined, questionToken: Token<SyntaxKind.QuestionToken> | undefined);
    // (undocumented)
    readonly argumentList: ArgumentList | undefined;
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly name: Identifier;
    // (undocumented)
    update(name: Identifier, argumentList: ArgumentList | undefined): Nonterminal;
}

// @public
export class NoSymbolHereAssertion extends AssertionBase<SyntaxKind.NoSymbolHereAssertion, SyntaxKind.OpenBracketToken> {
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketToken>, noKeyword: Token<SyntaxKind.NoKeyword>, symbols: ReadonlyArray<PrimarySymbol> | undefined, hereKeyword: Token<SyntaxKind.HereKeyword> | undefined, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    readonly hereKeyword: Token<SyntaxKind.HereKeyword> | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly noKeyword: Token<SyntaxKind.NoKeyword>;
    // (undocumented)
    readonly symbols: ReadonlyArray<PrimarySymbol> | undefined;
    // (undocumented)
    update(symbols: ReadonlyArray<PrimarySymbol> | undefined): NoSymbolHereAssertion;
}

// @public (undocumented)
export class NullDiagnosticMessages extends DiagnosticMessages {
    // (undocumented)
    copyFrom(other: DiagnosticMessages): void;
    // (undocumented)
    static get instance(): NullDiagnosticMessages;
    // (undocumented)
    report(pos: number, message: Diagnostic, ...args: any[]): void;
    // (undocumented)
    reportNode(sourceFile: SourceFile | undefined, node: Node_2, message: Diagnostic, ...args: any[]): void;
    // (undocumented)
    setSourceFile(sourceFile: SourceFile): void;
    // (undocumented)
    get size(): number;
}

// @public
export class OneOfList extends Node_2<SyntaxKind.OneOfList> {
    constructor(oneKeyword: Token<SyntaxKind.OneKeyword>, ofKeyword: Token<SyntaxKind.OfKeyword> | undefined, indented: boolean, terminals: ReadonlyArray<Terminal> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    readonly indented: boolean;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly ofKeyword: Token<SyntaxKind.OfKeyword> | undefined;
    // (undocumented)
    readonly oneKeyword: Token<SyntaxKind.OneKeyword>;
    // (undocumented)
    readonly terminals: ReadonlyArray<Terminal> | undefined;
    // (undocumented)
    update(terminals: ReadonlyArray<Terminal> | undefined): OneOfList;
}

// @public
export class OneOfSymbol extends LexicalSymbolBase<SyntaxKind.OneOfSymbol> {
    constructor(oneKeyword: Token<SyntaxKind.OneKeyword>, ofKeyword: Token<SyntaxKind.OfKeyword> | undefined, symbols: ReadonlyArray<LexicalSymbol> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly ofKeyword: Token<SyntaxKind.OfKeyword> | undefined;
    // (undocumented)
    readonly oneKeyword: Token<SyntaxKind.OneKeyword>;
    // (undocumented)
    readonly symbols: ReadonlyArray<LexicalSymbol> | undefined;
    // (undocumented)
    update(symbols: ReadonlyArray<LexicalSymbol> | undefined): OneOfSymbol;
}

// @public (undocumented)
export type OptionalSymbol = OptionalSymbolTypes[OptionalSymbolKind];

// @public
export abstract class OptionalSymbolBase<TKind extends OptionalSymbolKind> extends PrimarySymbolBase<TKind> {
    constructor(kind: TKind, questionToken: Token<SyntaxKind.QuestionToken> | undefined);
    // (undocumented)
    readonly questionToken: Token<SyntaxKind.QuestionToken> | undefined;
}

// @public (undocumented)
export type OptionalSymbolKind = keyof OptionalSymbolTypes;

// @public (undocumented)
export interface OptionalSymbolTypes {
}

// @public (undocumented)
export interface OptionalSymbolTypes {
    // (undocumented)
    [SyntaxKind.UnicodeCharacterLiteral]: UnicodeCharacterLiteral;
}

// @public (undocumented)
export interface OptionalSymbolTypes {
    // (undocumented)
    [SyntaxKind.Terminal]: Terminal;
}

// @public (undocumented)
export interface OptionalSymbolTypes {
    // (undocumented)
    [SyntaxKind.Nonterminal]: Nonterminal;
}

// @public
export class Parameter extends Node_2<SyntaxKind.Parameter> {
    constructor(name: Identifier);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly name: Identifier;
    // (undocumented)
    update(name: Identifier): Parameter;
}

// @public
export class ParameterList extends Node_2<SyntaxKind.ParameterList> {
    constructor(openParenToken: Token<SyntaxKind.OpenParenToken | SyntaxKind.OpenBracketToken>, elements: ReadonlyArray<Parameter> | undefined, closeParenToken: Token<SyntaxKind.CloseParenToken | SyntaxKind.CloseBracketToken> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    readonly closeParenToken: Token<SyntaxKind.CloseParenToken | SyntaxKind.CloseBracketToken> | undefined;
    // (undocumented)
    readonly elements: ReadonlyArray<Parameter> | undefined;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly openParenToken: Token<SyntaxKind.OpenParenToken | SyntaxKind.OpenBracketToken>;
    // (undocumented)
    update(elements: ReadonlyArray<Parameter> | undefined): ParameterList;
}

// @public (undocumented)
export type ParameterOperatorKind = SyntaxKind.PlusToken | SyntaxKind.TildeToken;

// @public (undocumented)
export function parse<T extends ParsedArguments>(options: KnownOptions, args?: string[]): T | undefined;

// @public (undocumented)
export interface ParsedArguments {
    // (undocumented)
    [key: string]: any;
    // (undocumented)
    argv: string[];
    // (undocumented)
    rest: string[];
}

// @public (undocumented)
export class Parser {
    // (undocumented)
    parseSourceFile(filename: string, text: string, cancelable?: Cancelable): SourceFile;
    // @deprecated (undocumented)
    parseSourceFile(filename: string, text: string, cancelable?: CancellationToken | Cancelable): SourceFile;
    }

// @public
export class PlaceholderSymbol extends LexicalSymbolBase<SyntaxKind.PlaceholderSymbol> {
    constructor(placeholderToken: Token<SyntaxKind.AtToken>);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly placeholderToken: Token<SyntaxKind.AtToken>;
}

// @public (undocumented)
interface Position_2 {
    // (undocumented)
    character: number;
    // (undocumented)
    line: number;
}

// @public (undocumented)
namespace Position_2 {
    // (undocumented)
    function clone(position: Position_2): Position_2;
    // (undocumented)
    function compare(left: Position_2, right: Position_2): 1 | 0 | -1;
    // (undocumented)
    function create(line: number, character: number): Position_2;
    // (undocumented)
    function equals(left: Position_2, right: Position_2): boolean;
}

export { Position_2 as Position }

// @public (undocumented)
export type PrimarySymbol = PrimarySymbolTypes[PrimarySymbolKind];

// @public
export abstract class PrimarySymbolBase<TKind extends PrimarySymbolKind> extends LexicalSymbolBase<TKind> {
}

// @public (undocumented)
export type PrimarySymbolKind = keyof PrimarySymbolTypes;

// @public (undocumented)
export interface PrimarySymbolTypes extends OptionalSymbolTypes {
}

// @public
export class Production extends SourceElementBase<SyntaxKind.Production> {
    constructor(name: Identifier, parameterList: ParameterList | undefined, colonToken: Token<ProductionSeperatorKind> | undefined, body: ProductionBody | undefined);
    // (undocumented)
    readonly body: ProductionBody | undefined;
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    readonly colonToken: Token<ProductionSeperatorKind> | undefined;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly name: Identifier;
    // (undocumented)
    readonly parameterList: ParameterList | undefined;
    // (undocumented)
    update(name: Identifier, parameterList: ParameterList | undefined, body: ProductionBody | undefined): Production;
}

// @public (undocumented)
export type ProductionBody = ProductionBodyTypes[ProductionBodyKind];

// @public (undocumented)
export type ProductionBodyKind = keyof ProductionBodyTypes;

// @public (undocumented)
export interface ProductionBodyTypes {
    // (undocumented)
    [SyntaxKind.RightHandSide]: RightHandSide;
}

// @public (undocumented)
export interface ProductionBodyTypes {
    // (undocumented)
    [SyntaxKind.RightHandSideList]: RightHandSideList;
}

// @public (undocumented)
export interface ProductionBodyTypes {
    // (undocumented)
    [SyntaxKind.OneOfList]: OneOfList;
}

// @public (undocumented)
export interface ProductionBodyTypes {
}

// @public (undocumented)
export type ProductionSeperatorKind = SyntaxKind.ColonToken | SyntaxKind.ColonColonToken | SyntaxKind.ColonColonColonToken;

// @public
export class Prose extends LexicalSymbolBase<SyntaxKind.Prose> {
    constructor(greaterThanToken: Token<SyntaxKind.GreaterThanToken>, fragments: ReadonlyArray<ProseFragment> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    readonly fragments: ReadonlyArray<ProseFragment> | undefined;
    // (undocumented)
    readonly greaterThanToken: Token<SyntaxKind.GreaterThanToken>;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    update(fragments: ReadonlyArray<ProseFragment> | undefined): Prose;
}

// @public
export class ProseAssertion extends AssertionBase<SyntaxKind.ProseAssertion, SyntaxKind.OpenBracketGreaterThanToken> {
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketGreaterThanToken>, fragments: ReadonlyArray<ProseFragment> | undefined, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    readonly fragments: ReadonlyArray<ProseFragment> | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    update(fragments: ReadonlyArray<ProseFragment> | undefined): ProseAssertion;
}

// @public (undocumented)
export type ProseFragment = ProseFragmentTypes[ProseFragmentKind];

// @public (undocumented)
export type ProseFragmentKind = keyof ProseFragmentTypes;

// @public
export class ProseFragmentLiteral<TKind extends ProseFragmentLiteralKind = ProseFragmentLiteralKind> extends Node_2<SyntaxKind> implements TextContent {
    constructor(kind: SyntaxKind, text: string | undefined);
    // (undocumented)
    readonly text: string | undefined;
}

// @public (undocumented)
export type ProseFragmentLiteralKind = SyntaxKind.ProseFull | SyntaxKind.ProseHead | SyntaxKind.ProseMiddle | SyntaxKind.ProseTail;

// @public (undocumented)
export type ProseFragmentLiteralTypes = {
    [P in ProseFragmentLiteralKind]: ProseFragmentLiteral<P>;
};

// @public (undocumented)
export interface ProseFragmentTypes {
    // (undocumented)
    [SyntaxKind.Terminal]: Terminal;
}

// @public (undocumented)
export interface ProseFragmentTypes {
    // (undocumented)
    [SyntaxKind.Nonterminal]: Nonterminal;
}

// @public (undocumented)
export interface ProseFragmentTypes extends ProseFragmentLiteralTypes {
}

// @public (undocumented)
export interface ProseFragmentTypes {
}

// @public (undocumented)
export type PunctuationKind = SyntaxKind.AtToken | SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.OpenBracketToken | SyntaxKind.OpenBracketGreaterThanToken | SyntaxKind.CloseBracketToken | SyntaxKind.GreaterThanToken | SyntaxKind.OpenParenToken | SyntaxKind.CloseParenToken | SyntaxKind.ColonToken | SyntaxKind.ColonColonToken | SyntaxKind.ColonColonColonToken | SyntaxKind.CommaToken | SyntaxKind.PlusToken | SyntaxKind.TildeToken | SyntaxKind.QuestionToken | SyntaxKind.EqualsToken | SyntaxKind.EqualsEqualsToken | SyntaxKind.ExclamationEqualsToken | SyntaxKind.LessThanExclamationToken | SyntaxKind.LessThanMinusToken | SyntaxKind.NotEqualToToken | SyntaxKind.ElementOfToken | SyntaxKind.NotAnElementOfToken;

// @public (undocumented)
interface Range_2 {
    // (undocumented)
    end: Position_2;
    // (undocumented)
    start: Position_2;
}

// @public (undocumented)
namespace Range_2 {
    // (undocumented)
    function clone(range: Range_2): Range_2;
    // (undocumented)
    function collapseToEnd(range: Range_2): Range_2;
    // (undocumented)
    function collapseToStart(range: Range_2): Range_2;
    // (undocumented)
    function contains(left: Range_2, right: Range_2): boolean;
    // (undocumented)
    function containsPosition(range: Range_2, position: Position_2): boolean;
    // (undocumented)
    function create(start: Position_2, end: Position_2): Range_2;
    // (undocumented)
    function equals(left: Range_2, right: Range_2): boolean;
    // (undocumented)
    function intersects(left: Range_2, right: Range_2): boolean;
    // (undocumented)
    function isCollapsed(range: Range_2): boolean;
}

export { Range_2 as Range }

// @public (undocumented)
export interface RawArgument {
    // (undocumented)
    formattedKey: string;
    // (undocumented)
    option: KnownOption;
    // (undocumented)
    rawKey: string;
    // (undocumented)
    value: any;
}

// @public (undocumented)
export interface RawArguments {
    // (undocumented)
    args: RawArgument[];
    // (undocumented)
    rest: string[];
}

// @public (undocumented)
export type ReadFileCallback = (this: never, file: string, cancelToken?: CancelToken) => PromiseLike<string> | string;

// @public (undocumented)
export type ReadFileSyncCallback = (this: never, file: string, cancelToken?: CancelToken) => string;

// @public (undocumented)
export class Resolver {
    constructor(bindings: BindingTable);
    // (undocumented)
    createNavigator(node: Node_2): NodeNavigator | undefined;
    // (undocumented)
    getDeclarations(node: Identifier): (SourceFile | Production | Parameter)[];
    // (undocumented)
    getParent(node: Node_2): Node_2 | undefined;
    // (undocumented)
    getProductionLinkId(node: Identifier): string | undefined;
    // (undocumented)
    getReferences(node: Identifier): Node_2<SyntaxKind>[];
    // (undocumented)
    getRightHandSideLinkId(node: RightHandSide, includePrefix: boolean): string;
    // (undocumented)
    getSourceFileOfNode(node: Node_2): SourceFile;
}

// @public
export class RightHandSide extends Node_2<SyntaxKind.RightHandSide> {
    constructor(constraints: Constraints | undefined, head: SymbolSpan | undefined, reference: LinkReference | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    readonly constraints: Constraints | undefined;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    readonly head: SymbolSpan | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly reference: LinkReference | undefined;
    // (undocumented)
    update(constraints: Constraints | undefined, head: SymbolSpan | undefined, reference: LinkReference | undefined): RightHandSide;
}

// @public
export class RightHandSideList extends Node_2<SyntaxKind.RightHandSideList> {
    constructor(elements: ReadonlyArray<RightHandSide> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    readonly elements: ReadonlyArray<RightHandSide> | undefined;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    update(elements: ReadonlyArray<RightHandSide> | undefined): RightHandSideList;
}

// @public (undocumented)
export function scanHtmlTrivia(text: string, pos: number, end: number): HtmlTrivia[] | undefined;

// @public (undocumented)
export class Scanner {
    constructor(filename: string, text: string, diagnostics: DiagnosticMessages, cancelable?: Cancelable);
    // @deprecated
    constructor(filename: string, text: string, diagnostics: DiagnosticMessages, cancelable?: CancellationToken | Cancelable);
    // (undocumented)
    readonly filename: string;
    // (undocumented)
    getDiagnostics(): DiagnosticMessages;
    // (undocumented)
    getHtmlTrivia(): (HtmlOpenTagTrivia | HtmlCloseTagTrivia)[] | undefined;
    // (undocumented)
    getLen(): number;
    // (undocumented)
    getPos(): number;
    // (undocumented)
    getStartPos(): number;
    // (undocumented)
    getToken(): SyntaxKind;
    // (undocumented)
    getTokenIsUnterminated(): boolean;
    // (undocumented)
    getTokenPos(): number;
    // (undocumented)
    getTokenText(): string;
    // (undocumented)
    getTokenValue(): string;
    // (undocumented)
    hasPrecedingBlankLine(): boolean;
    // (undocumented)
    hasPrecedingDedent(): boolean;
    // (undocumented)
    hasPrecedingIndent(): boolean;
    // (undocumented)
    hasPrecedingLineTerminator(): boolean;
    // (undocumented)
    hasPrecedingNewLine(): boolean;
    // (undocumented)
    isIndented(): boolean;
    // (undocumented)
    isLineContinuation(): boolean;
    // (undocumented)
    scan(): SyntaxKind;
    // (undocumented)
    speculate<T>(callback: () => T, isLookahead: boolean): T;
    // (undocumented)
    readonly text: string;
    }

// @public @deprecated (undocumented)
export class SingleFileHost extends Host {
    constructor(content: string, file?: string, hostFallback?: Host);
    // (undocumented)
    readonly content: string;
    // (undocumented)
    protected createParser(): Parser;
    // (undocumented)
    readonly file: string;
    // (undocumented)
    getSourceFile(file: string, cancelable?: Cancelable): Promise<SourceFile | undefined>;
    // @deprecated (undocumented)
    getSourceFile(file: string, cancelable?: CancellationToken | Cancelable): Promise<SourceFile | undefined>;
    // (undocumented)
    getSourceFileSync(file: string, cancelable?: Cancelable): SourceFile | undefined;
    // @deprecated (undocumented)
    getSourceFileSync(file: string, cancelable?: CancellationToken | Cancelable): SourceFile | undefined;
    // (undocumented)
    normalizeFile(file: string): string;
    // (undocumented)
    protected get parser(): Parser;
    // (undocumented)
    readFile(file: string, cancelable?: Cancelable): Promise<string | undefined>;
    // @deprecated (undocumented)
    readFile(file: string, cancelable?: CancellationToken | Cancelable): Promise<string | undefined>;
    // (undocumented)
    readFileSync(file: string, cancelable?: Cancelable): string | undefined;
    // @deprecated (undocumented)
    readFileSync(file: string, cancelable?: CancellationToken | Cancelable): string | undefined;
    // (undocumented)
    registerKnownGrammar(_name: string, _file: string): void;
    // (undocumented)
    protected resolveBuiltInGrammar(name: string): string | undefined;
    // (undocumented)
    resolveFile(file: string, referer?: string): string;
    // (undocumented)
    resolveKnownGrammar(name: string): string | undefined;
    // (undocumented)
    writeFile(file: string, text: string, cancelable?: Cancelable): Promise<void>;
    // @deprecated (undocumented)
    writeFile(file: string, text: string, cancelable?: CancellationToken | Cancelable): Promise<void>;
    // (undocumented)
    writeFileSync(file: string, text: string, cancelable?: Cancelable): void;
    // @deprecated (undocumented)
    writeFileSync(file: string, text: string, cancelable?: CancellationToken | Cancelable): void;
}

// @public
export class SingleLineCommentTrivia extends CommentTriviaBase<SyntaxKind.SingleLineCommentTrivia> {
    constructor();
}

// @public (undocumented)
export function skipTrivia(text: string, pos: number, end: number, htmlTrivia?: HtmlTrivia[], commentTrivia?: CommentTrivia[]): number;

// @public (undocumented)
export type SourceElement = SourceElementTypes[SourceElementKind];

// @public
export abstract class SourceElementBase<TKind extends SyntaxKind = SyntaxKind> extends Node_2<TKind> {
}

// @public (undocumented)
export type SourceElementKind = keyof SourceElementTypes;

// @public (undocumented)
export interface SourceElementTypes {
}

// @public (undocumented)
export interface SourceElementTypes {
    // (undocumented)
    [SyntaxKind.Production]: Production;
}

// @public (undocumented)
export interface SourceElementTypes extends MetaElementTypes {
}

// @public
export class SourceFile extends Node_2<SyntaxKind.SourceFile> {
    constructor(filename: string, text: string, elements: ReadonlyArray<SourceElement>);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    readonly elements: ReadonlyArray<SourceElement>;
    // (undocumented)
    readonly filename: string;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    imports: ReadonlyArray<string> | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly lineMap: LineMap;
    // (undocumented)
    readonly text: string;
    // (undocumented)
    update(elements: ReadonlyArray<SourceElement>): SourceFile;
}

// @public
export class StringLiteral extends Node_2<SyntaxKind.StringLiteral> implements TextContent {
    constructor(text: string | undefined);
    // (undocumented)
    readonly text: string | undefined;
}

// @public (undocumented)
export function stringToToken(text: string): SyntaxKind | undefined;

// @public (undocumented)
export class StringWriter {
    constructor(eol?: string);
    // (undocumented)
    dedent(): void;
    // (undocumented)
    indent(): void;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toString(): string;
    // (undocumented)
    write(text?: string): void;
    // (undocumented)
    writeln(text?: string): void;
}

// @public (undocumented)
class Symbol_2 {
    constructor(kind: SymbolKind, name: string);
    // (undocumented)
    id: number;
    // (undocumented)
    kind: SymbolKind;
    // (undocumented)
    locals: SymbolTable | undefined;
    // (undocumented)
    name: string;
    // (undocumented)
    parent: Symbol_2 | undefined;
}

export { Symbol_2 as Symbol }

// @public (undocumented)
export enum SymbolKind {
    // (undocumented)
    Parameter = 2,
    // (undocumented)
    Production = 1,
    // (undocumented)
    SourceFile = 0
}

// @public
export class SymbolSet extends Node_2<SyntaxKind.SymbolSet> {
    constructor(openBraceToken: Token<SyntaxKind.OpenBraceToken>, elements: ReadonlyArray<SymbolSpan> | undefined, closeBraceToken: Token<SyntaxKind.CloseBraceToken> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    readonly closeBraceToken: Token<SyntaxKind.CloseBraceToken> | undefined;
    // (undocumented)
    readonly elements: ReadonlyArray<SymbolSpan> | undefined;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly openBraceToken: Token<SyntaxKind.OpenBraceToken>;
    // (undocumented)
    update(elements: ReadonlyArray<SymbolSpan> | undefined): SymbolSet;
}

// @public
export class SymbolSpan extends Node_2<SyntaxKind.SymbolSpan> {
    constructor(symbol: LexicalSymbol, next: SymbolSpan | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly next: SymbolSpan | undefined;
    // (undocumented)
    readonly symbol: LexicalSymbol;
    // (undocumented)
    update(symbol: LexicalSymbol, next: SymbolSpan | undefined): SymbolSpan;
}

// @public (undocumented)
export class SymbolTable {
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    resolveSymbol(name: string, kind: SymbolKind): Symbol_2 | undefined;
}

// @public (undocumented)
export class SyncHost extends HostBase {
    constructor({ readFileSync, writeFileSync, ...baseOptions }?: SyncHostOptions);
    // (undocumented)
    static forFile(content: string, file?: string, hostFallback?: SyncHost): SyncSingleFileHost;
    // (undocumented)
    getSourceFileSync(file: string, cancelable?: Cancelable): SourceFile | undefined;
    // @deprecated (undocumented)
    getSourceFileSync(file: string, cancelable?: CancellationToken | Cancelable): SourceFile | undefined;
    // (undocumented)
    readFileSync(file: string, cancelable?: Cancelable): string | undefined;
    // @deprecated (undocumented)
    readFileSync(file: string, cancelable?: CancellationToken | Cancelable): string | undefined;
    // (undocumented)
    writeFileSync(file: string, text: string, cancelable?: Cancelable): void;
    // @deprecated (undocumented)
    writeFileSync(file: string, text: string, cancelable?: CancellationToken | Cancelable): void;
    }

// @public (undocumented)
export interface SyncHostOptions extends HostBaseOptions {
    // (undocumented)
    readFileSync?: LegacyReadFileSyncCallback | ReadFileSyncCallback | false;
    // (undocumented)
    writeFileSync?: LegacyWriteFileSyncCallback | WriteFileSyncCallback | false;
}

// @public (undocumented)
export class SyncSingleFileHost extends SyncHost {
    constructor(file: string, content: string, hostFallback?: SyncHost);
    // (undocumented)
    readonly content: string;
    // (undocumented)
    readonly file: string;
    // (undocumented)
    normalizeFile(file: string): string;
    // (undocumented)
    readFileSync(file: string, cancelable?: Cancelable): string | undefined;
    // @deprecated (undocumented)
    readFileSync(file: string, cancelable?: CancellationToken | Cancelable): string | undefined;
    // (undocumented)
    resolveFile(file: string, referer?: string): string;
    // (undocumented)
    writeFileSync(file: string, text: string, cancelable?: Cancelable): void;
    // @deprecated (undocumented)
    writeFileSync(file: string, text: string, cancelable?: CancellationToken | Cancelable): void;
}

// @public (undocumented)
export enum SyntaxKind {
    // (undocumented)
    Argument = 60,
    // (undocumented)
    ArgumentList = 61,
    // (undocumented)
    AtToken = 6,
    // (undocumented)
    ButKeyword = 30,
    // (undocumented)
    ButNotSymbol = 69,
    // (undocumented)
    CloseBraceToken = 8,
    // (undocumented)
    CloseBracketToken = 11,
    // (undocumented)
    CloseParenToken = 14,
    // (undocumented)
    ColonColonColonToken = 17,
    // (undocumented)
    ColonColonToken = 16,
    // (undocumented)
    ColonToken = 15,
    // (undocumented)
    CommaToken = 18,
    // (undocumented)
    Constraints = 66,
    // (undocumented)
    Define = 56,
    // (undocumented)
    DefineKeyword = 31,
    // (undocumented)
    ElementOfToken = 28,
    // (undocumented)
    EmptyAssertion = 75,
    // (undocumented)
    EmptyKeyword = 32,
    // (undocumented)
    EndOfFileToken = 5,
    // (undocumented)
    EqualsEqualsToken = 23,
    // (undocumented)
    EqualsToken = 22,
    // (undocumented)
    ExclamationEqualsToken = 24,
    // (undocumented)
    FalseKeyword = 33,
    // (undocumented)
    FirstCommentTrivia = 1,
    // (undocumented)
    FirstErrorNode = 80,
    // (undocumented)
    FirstHtmlTrivia = 3,
    // (undocumented)
    FirstKeyword = 30,
    // (undocumented)
    FirstLiteral = 46,
    // (undocumented)
    FirstProseFragmentLiteral = 49,
    // (undocumented)
    FirstPunctuation = 6,
    // (undocumented)
    FirstTextContent = 46,
    // (undocumented)
    FirstToken = 5,
    // (undocumented)
    FirstTrivia = 1,
    // (undocumented)
    GoalKeyword = 34,
    // (undocumented)
    GreaterThanToken = 12,
    // (undocumented)
    HereKeyword = 35,
    // (undocumented)
    HtmlCloseTagTrivia = 4,
    // (undocumented)
    HtmlOpenTagTrivia = 3,
    // (undocumented)
    Identifier = 53,
    // (undocumented)
    Import = 55,
    // (undocumented)
    ImportKeyword = 36,
    // (undocumented)
    InvalidAssertion = 81,
    // (undocumented)
    InvalidSymbol = 80,
    // (undocumented)
    LastCommentTrivia = 2,
    // (undocumented)
    LastErrorNode = 81,
    // (undocumented)
    LastHtmlTrivia = 4,
    // (undocumented)
    LastKeyword = 45,
    // (undocumented)
    LastLiteral = 48,
    // (undocumented)
    LastProseFragmentLiteral = 52,
    // (undocumented)
    LastPunctuation = 29,
    // (undocumented)
    LastTextContent = 52,
    // (undocumented)
    LastToken = 45,
    // (undocumented)
    LastTrivia = 4,
    // (undocumented)
    LessThanExclamationToken = 25,
    // (undocumented)
    LessThanMinusToken = 26,
    // (undocumented)
    LexicalGoalAssertion = 77,
    // (undocumented)
    LexicalKeyword = 37,
    // (undocumented)
    LinkReference = 62,
    // (undocumented)
    LookaheadAssertion = 76,
    // (undocumented)
    LookaheadKeyword = 38,
    // (undocumented)
    MultiLineCommentTrivia = 2,
    // (undocumented)
    NoKeyword = 39,
    // (undocumented)
    Nonterminal = 73,
    // (undocumented)
    NoSymbolHereAssertion = 78,
    // (undocumented)
    NotAnElementOfToken = 29,
    // (undocumented)
    NotEqualToToken = 27,
    // (undocumented)
    NotKeyword = 40,
    // (undocumented)
    OfKeyword = 41,
    // (undocumented)
    OneKeyword = 42,
    // (undocumented)
    OneOfList = 63,
    // (undocumented)
    OneOfSymbol = 71,
    // (undocumented)
    OpenBraceToken = 7,
    // (undocumented)
    OpenBracketGreaterThanToken = 10,
    // (undocumented)
    OpenBracketToken = 9,
    // (undocumented)
    OpenParenToken = 13,
    // (undocumented)
    OrKeyword = 43,
    // (undocumented)
    Parameter = 58,
    // (undocumented)
    ParameterList = 59,
    // (undocumented)
    PlaceholderSymbol = 72,
    // (undocumented)
    PlusToken = 19,
    // (undocumented)
    Production = 57,
    // (undocumented)
    Prose = 74,
    // (undocumented)
    ProseAssertion = 79,
    // (undocumented)
    ProseFull = 52,
    // (undocumented)
    ProseHead = 49,
    // (undocumented)
    ProseMiddle = 50,
    // (undocumented)
    ProseTail = 51,
    // (undocumented)
    QuestionToken = 21,
    // (undocumented)
    RightHandSide = 65,
    // (undocumented)
    RightHandSideList = 64,
    // (undocumented)
    SingleLineCommentTrivia = 1,
    // (undocumented)
    SourceFile = 54,
    // (undocumented)
    StringLiteral = 46,
    // (undocumented)
    SymbolSet = 68,
    // (undocumented)
    SymbolSpan = 67,
    // (undocumented)
    Terminal = 47,
    // (undocumented)
    ThroughKeyword = 44,
    // (undocumented)
    TildeToken = 20,
    // (undocumented)
    TrueKeyword = 45,
    // (undocumented)
    UnicodeCharacterLiteral = 48,
    // (undocumented)
    UnicodeCharacterRange = 70,
    // (undocumented)
    Unknown = 0
}

// @public
export class Terminal extends OptionalSymbolBase<SyntaxKind.Terminal> implements TextContent {
    constructor(text: string | undefined, questionToken: Token<SyntaxKind.QuestionToken> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly text: string | undefined;
}

// @public (undocumented)
export interface TextChange {
    // (undocumented)
    range: Range_2;
    // (undocumented)
    text: string;
}

// @public (undocumented)
export namespace TextChange {
    // (undocumented)
    export function applyChange(originalText: string, change: TextChange): string;
    // (undocumented)
    export function clone(change: TextChange): {
        text: string;
        range: Range_2;
    };
    // (undocumented)
    export function create(text: string, range: Range_2): {
        text: string;
        range: Range_2;
    };
    // (undocumented)
    export function isUnchanged(change: TextChange): boolean;
}

// @public
export interface TextContent {
    // (undocumented)
    text: string | undefined;
}

// @public (undocumented)
export type TextContentKind = SyntaxKind.StringLiteral | SyntaxKind.Terminal | SyntaxKind.UnicodeCharacterLiteral | ProseFragmentLiteralKind | SyntaxKind.Identifier;

// @public
export class Token<TKind extends TokenKind = TokenKind> extends Node_2<TKind> {
}

// @public (undocumented)
export type TokenKind = SyntaxKind.EndOfFileToken | PunctuationKind | KeywordKind;

// @public (undocumented)
export function tokenToString(kind: SyntaxKind | string, quoted?: boolean): string;

// @public (undocumented)
export type Trivia = TriviaTypes[TriviaKind];

// @public
export abstract class TriviaBase<TKind extends TriviaKind> extends Node_2<TKind> {
}

// @public (undocumented)
export type TriviaKind = CommentTriviaKind | HtmlTriviaKind;

// @public (undocumented)
export interface TriviaTypes extends HtmlTriviaTypes, CommentTriviaTypes {
}

// @public
export class UnicodeCharacterLiteral extends OptionalSymbolBase<SyntaxKind.UnicodeCharacterLiteral> implements TextContent {
    constructor(text: string | undefined, questionToken: Token<SyntaxKind.QuestionToken> | undefined);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly text: string | undefined;
}

// @public
export class UnicodeCharacterRange extends LexicalSymbolBase<SyntaxKind.UnicodeCharacterRange> {
    constructor(left: UnicodeCharacterLiteral, throughKeyword: Token<SyntaxKind.ThroughKeyword>, right: UnicodeCharacterLiteral);
    // (undocumented)
    children(): IterableIterator<Node_2>;
    // (undocumented)
    get firstChild(): Node_2 | undefined;
    // (undocumented)
    forEachChild<T>(cbNode: (node: Node_2) => T | undefined): T | undefined;
    // (undocumented)
    get lastChild(): Node_2 | undefined;
    // (undocumented)
    readonly left: UnicodeCharacterLiteral;
    // (undocumented)
    readonly right: UnicodeCharacterLiteral;
    // (undocumented)
    readonly throughKeyword: Token<SyntaxKind.ThroughKeyword>;
    // (undocumented)
    update(left: UnicodeCharacterLiteral, right: UnicodeCharacterLiteral): UnicodeCharacterRange;
}

// @public (undocumented)
export function usage(options: KnownOptions, margin?: number, printHeader?: (writer: UsageWriter) => void): void;

// @public (undocumented)
export class UsageWriter {
    constructor(margin: number, padding: number);
    // (undocumented)
    writeln(text?: string): void;
    // (undocumented)
    writeOption(left: string | undefined, right: string | undefined): void;
}

// @public (undocumented)
export type WriteFileCallback = (this: never, file: string, content: string, cancelToken?: CancelToken) => PromiseLike<void> | void;

// @public (undocumented)
export type WriteFileSyncCallback = (this: never, file: string, content: string, cancelToken?: CancelToken) => void;


// (No @packageDocumentation comment for this package)

```
